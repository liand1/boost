### 事务的ACID
+ atomicity 原子性，一个事务必须被视为一个不可分割的最小工作单元，整个事务的所有操作要么全部提交成功，要么全部失败
+ consistency 一致性，数据库总是从一个一致性的状态转换到另一个一致性的状态。一致性保证了事务中的某些语句执行失败，前面所作的修改
    不会保存到数据库中  
+ isolation 隔离性，通常来说，一个事务所作的修改在最终提交前，对其他事务是不可见的。它与事务的隔离级别有关  
+ durability 持久性, 一旦事务提交，所做的修改就会永久保存到数据库中。即便系统崩溃，修改的数据也不会丢失。

#### 隔离级别
在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所作的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常
可以执行更高的并发，系统的开销也更低。  
1 `READ UNCOMMITTED(未提交读)`    
    在这个级别中，事务中的修改，即便没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。  
2 `READ COMMITTED(提交读)`  
    大多数数据库系统的默认隔离级别都是它(但MYSQL不是)。它满足前面提到的隔离性的简单定义：一个事务开始时，只能看见已经提交的事务所作的修改。
    换句话说，一个事务从开始到提交之前，所做的任何修改对其他事务都不是可见的。这个级别又时候也叫做不可重复读，因为两次执行同样的查询，
    可能会得到不一样的结果。  
3 `REPEATABLE READ(可重复读)`  
    MYSQL的默认事务隔离级别。它解决了脏读的问题。该级别保证了同一事务中多次读取同样记录的结果是一致的。但是理论上，它还是无法解决另外一个幻读
    的问题，所谓幻读，指的是某个事务在读取某个范围的记录时，另外一个事务又在该分为插入了新的数据，当之前的事务再次读取该范围的记录时，会产生
    幻行    
4 `SERIALIZABLE(可串行化)`       
    最高的隔离级别，通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，它会在读取的每一行都加锁，所以可能导致大量的超时和锁争用的问题。
    
 |隔离级别|脏读可能性|不可重复读可能性|幻读可能性|加锁读|  
 |:----|:----|:----|:----|:----|  
 |READ UNCOMMITTED| Y|Y|Y|N|  
 |READ COMMITTED| N|Y|Y|N|  
 |REPEATABLE READ| N|N|Y|N|  
 |SERIALIZABLE|N|N|N|Y|    
    