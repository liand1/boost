TCP/IP是internet的支撑协议，是目前使用最广泛的协议

### 主要优点
+ 简单 灵活 易于实现
+ 充分考虑不同用户的需求

#### UDP & TCP
TCP 是面向连接的，UDP 是面向无连接的。

什么叫面向连接，什么叫无连接呢？在互通之前，面向连接的协议会先建立连接。例如，TCP 会三次握手，而 UDP 不会

`所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。`

`TCP 提供可靠交付`。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。我们都知道 IP 包是没有任何可靠性保证的，一旦发出
去，就像西天取经，走丢了、被妖怪吃了，都只能随它去。但是 TCP 号称能做到那个连接维护的程序做的事情，这个下两节我会详细描述。而 UDP 
继承了 IP 包的特性，不保证不丢失，不保证按顺序到达。

`TCP 是面向字节流的`。发送的时候发的是一个流，没头没尾。IP 包可不是一个流，而是一个个的 IP 包。之所以变成了流，这也是 TCP 自己的状
态维护做的事情。而 UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收。

`TCP 是可以有拥塞控制的`。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。UDP 就
不会，应用让我发，我就发，管它洪水滔天。

因而 `TCP 其实是一个有状态服务`，通俗地讲就是有脑子的，里面精确地记着发送了没有，接收到没有，发送到哪个了，应该接收哪个了，错一
点儿都不行。而 `UDP 则是无状态服务`。通俗地说是没脑子的，天真无邪的，发出去就发出去了。

##### UDP
1 沟通简单
2 轻信他人
3 愣头青，做事不懂权变

应用场景：
第一，需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用
第二，不需要一对一沟通，建立连接，而是可以广播的应用
第三，需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候

`基于 UDP 协议的 Socket 程序函数调用过程`\
对于 UDP 来讲，过程有些不一样。UDP 是没有连接的，所以不需要三次握手，也就不需要调用 listen 和 connect，但是，UDP 的交互仍然需要
 IP 和端口号，因而也需要 bind。UDP 是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个
 客户端通信。也正是因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入 IP 地址和端口。


##### TCP
连接的建立是经过三次握手，断开的时候四次挥手

`基于 TCP 协议的 Socket 程序函数调用过程`
CP 的服务端要先监听一个端口，一般是先调用 bind 函数，给这个 Socket 赋予一个 IP 地址和端口。为什么需要端口呢？要知道，你写
的是一个应用程序，当一个网络包来的时候，内核要通过 TCP 头里面的这个端口，来找到你这个应用程序，把包给你。为什么要 IP 地址呢？
有时候，一台机器会有多个网卡，也就会有多个 IP 地址，你可以选择监听所有的网卡，也可以选择监听一个网卡，这样，只有发给这个网卡的
包，才会给你。

当服务端有了 IP 和端口号，就可以调用 listen 函数进行监听。在 TCP 的状态图里面，有一个 listen 状态，当调用这个函数之后，服务端
就进入了这个状态，这个时候客户端就可以发起连接了。

在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是
还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。

接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。

在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端口号，然后开始发起三次握手。内核
会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket。

这是一个经常考的知识点，就是监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作监听 Socket，一个叫作已连接 Socket。

##### 获取网络抓包
```
sudo tcpdump -nn -i eth0 port 80
新开一个窗口执行
curl www.baidu.com
```
打印如下信息（里面包含了3次握手和四次挥手）
```
listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes
21:35:55.207852 IP 192.168.124.128.48142 > 112.80.248.75.80: Flags [S], seq 2981556788, win 64240, options [mss 1460,sackOK,TS val 175606221 ecr 0,nop,wscale 7], length 0
21:35:55.237257 IP 112.80.248.75.80 > 192.168.124.128.48142: Flags [S.], seq 865936537, ack 2981556789, win 64240, options [mss 1460], length 0
21:35:55.237314 IP 192.168.124.128.48142 > 112.80.248.75.80: Flags [.], ack 1, win 64240, length 0
21:35:55.237381 IP 192.168.124.128.48142 > 112.80.248.75.80: Flags [P.], seq 1:78, ack 1, win 64240, length 77: HTTP: GET / HTTP/1.1
21:35:55.237504 IP 112.80.248.75.80 > 192.168.124.128.48142: Flags [.], ack 78, win 64240, length 0
21:35:55.269865 IP 112.80.248.75.80 > 192.168.124.128.48142: Flags [P.], seq 1:2782, ack 78, win 64240, length 2781: HTTP: HTTP/1.1 200 OK
21:35:55.269891 IP 192.168.124.128.48142 > 112.80.248.75.80: Flags [.], ack 2782, win 62780, length 0
21:35:55.270111 IP 192.168.124.128.48142 > 112.80.248.75.80: Flags [F.], seq 78, ack 2782, win 62780, length 0
21:35:55.270258 IP 112.80.248.75.80 > 192.168.124.128.48142: Flags [.], ack 79, win 64239, length 0
21:35:55.300599 IP 112.80.248.75.80 > 192.168.124.128.48142: Flags [FP.], seq 2782, ack 79, win 64239, length 0
21:35:55.300642 IP 192.168.124.128.48142 > 112.80.248.75.80: Flags [.], ack 2783, win 62780, length 0
```

##### 获取路由信息
```
route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
169.254.0.0     0.0.0.0         255.255.0.0     U     1000   0        0 ens33
0.0.0.0         192.168.124.2   0.0.0.0         UG    100    0        0 ens33
```
我们执行如下命令，ping百度
```
ping www.baidu.com
PING www.a.shifen.com (112.80.248.76) 56(84) bytes of data.
64 bytes from 112.80.248.76: icmp_seq=1 ttl=128 time=27.8 ms
```
112.80.248.76会先跟子网掩码每个位做与运算，先跟255.255.0.0做运算后的出来是112.80.0.0， 和Destination169.254.0.0 没有对上，会与下一条继续做与运算
与0.0.0.0得到的是0.0.0.0， 所以会交给网关192.168.124.2， 这也就是路由网关

我们ping内网ip， 比如是169.254.0.1
169.254.0.1会先跟子网掩码每个位做与运算，先跟255.255.0.0做运算后的出来是159.254.0.0，  所以会交给网关0.0.0.0， 这也就是局域网，0.0.0.0代表不会交给路由而直接发送


 