#### 远程调用
通过一个例子，来让你对远程调用和本地调用有一个直观了解。

以电商购物平台为例，每一笔交易都涉及订单系统、支付系统及库存系统，假设三个系统分别部署在三台机器 A、B、C 中独立运行，订单交易流程如下所示：
1 用户下单时，调用本地（机器 A）的订单系统进行下单；  
2 下单完成后，会远程调用机器 B 上的支付系统进行支付，待支付完成后返回结果，之后在本地更新订单状态；  
3 在本地远程调用机器 C 上的仓库系统出货，出货完成后返回出货结果。

在整个过程中，“下单”和“订单状态更新”两个操作属于本地调用，而“支付”和“出货”这两个操作是通过本地的订单系统调用其他两个机器上的函数（方法）实现的，属于远程调用。

`本地调用`通常指的是，进程内函数之间的相互调用；而`远程调用`,是进程间函数的相互调用，是进程间通信 IPC（Inter-Process Communication）的一种方式.  
通过远程调用，一个进程可以看到其他进程的函数、方法等

`根据进程是否部署在同一台机器上，远程调用可以分为如下两类`：
+ 本地过程调用（Local Procedure Call，LPC）
> 是指运行在同一台机器上的进程之间的互相通信，即在多进程操作系统中，运行的不同进程之间可以通过 LPC 进行函数调用。
+ 远程过程调用（Remote Procedure Call，RPC）
> 是指不同机器中运行的进程之间的相互通信，某一机器上运行的进程在不知道底层通信细节的情况下，就像访问本地服务一样，去调用远程机器上的服务

##### 远程调用的原理及应用
我们经常会听别人提起 B/S ( Browser/Server，浏览器 / 服务器) 架构。在这种架构中，被调用方（服务器）有一个开放的接口，然后调用
方（用户）通过 Browser 使用这个接口，来间接调用被调用方相应的服务，从而实现远程调用。

比如，用户 A 在自己的电脑上通过浏览器查询北京今天的天气， 浏览器会将用户查询请求通过远程调用方式调用远程服务器相应的服务，然后为用户返回北京今天的天气预报。

但是，`B/S 架构是基于 HTTP 协议实现的，每次调用接口时，都需要先进行 HTTP 请求`。这样既繁琐又浪费时间，不适用于有低时延要求的大规模分布式系统，所以远程调用的实现大多采用更底层的网络通信协议。

两种常用的远程调用机制：`远程过程调用` RPC(Remote Procedure Call) 和`远程方法调用 RMI`(Remote Method Invocation)。

#### RPC 的原理及应用
简单地说，RPC 就是调用方采用参数传递的方式，通过调用本机器上的一个函数或方法，去执行远程机器上的函数或方法（可以统称为服务），并返回结果。在整个过程中，RPC 会隐藏具体的通信细节。

订单系统进程并不需要知道底层是如何传输的，在用户眼里，远程过程调用和调用一次本地服务没什么不同。这，就是 RPC 的核心。

+ 第一个区别是，调用 ID 和函数的映射。
> 在本地调用中，进程内可共享内存地址空间，因此程序可直接通过函数名来调用函数。 但在 RPC 中，只通过函数名是不行的，因为不同进程的地址空间是不一样的。
> 
> 所以在 RPC 中，所有的函数必须要有一个调用 ID 来唯一标识。一个机器上运行的进程在做远程过程调用时，必须附上这个调用 ID。
> 另外，我们还需要在通信的两台机器间，分别维护一个函数与调用 ID 的映射表。两台机器维护的表中，相同的函数对应的调用 ID 必须保持一致。
>
> 当一台机器 A 上运行的进程 P 需要远程调用时，它就先查一下机器 A 维护的映射表，找出对应的调用 ID，然后把它传到另一台机器 B 上，机器 B 通过查看它维护的映射表，从而确定进程 P 需要调用的函数，然后执行对应的代码，最后将执行结果返回到进程 P。

+ 第二个区别是，序列化和反序列化。
> 在本地调用中，进程之间共享内存等，因此我们只需要把参数压到栈里，然后进程自己去栈里读取就行。但是在 RPC 中，两个进程分布在不同的机器上，使用的是不同机器的内存，因此不可能通过内存来传递参数。
>
> 而网络协议传输的内容是二进制流，无法直接传输参数的类型，因此这就需要调用方把参数先转成一个二进制流，传到被调用方后，被调用方再把二进制流转换成自己能读取的格式。这个过程，就叫作序列化和反序列化。
> 同理，被调用方返回的结果也需要有序列化和反序列化的过程，不然调用方无法获取到结果

+ 第三个区别是，网络传输协议。
> 序列化和反序列化解决了调用方和被调用方之间的数据传输格式问题，但要想序列化后的数据能在网络中顺利传输，还需要有相应的网络协议，比如 TCP、UDP 等，因此就需要有一个底层通信层。
>
> 用方通过该通信层把调用 ID 和序列化后的参数传给被调用方，被调用方同样需要该通信层将序列化后的调用结果返回到调用方。
>
> 也就是说，只要调用方和被调用方可以互传数据，就可以作为这个底层通信层。因此，它所使用的网络协议可以有很多，只要能完成网络传输即可。目前来看，`大部分 RPC 框架采用的是 TCP 协议`。

`以一个具有代表性的 RPC 框架 Apache Dubbo 为例`
Dubbo 的架构主要包括 4 部分：
+ 服务提供方。服务提供方会向服务注册中心注册自己提供的服务。
+ 服务注册中心。服务注册与发现中心，负责存储和管理服务提供方注册的服务信息和服务调用方订阅的服务类型等。
+ 服务调用方。根据服务注册中心返回的服务所在的地址列表，通过远程调用访问远程服务。
+ 监控中心。统计服务的调用次数和调用时间等信息的监控中心，以方便进行服务管理或服务失败分析等。

Dubbo 的大致工作流程如下：
1 服务提供方需要向服务注册中心注册自己提供的服务；    
2 服务调用方需要向注册中心预订调用服务的提供方地址列表；  
3 服务注册中心将服务对应的提供方地址列表返回给调用方；  
4 服务调用方根据服务地址信息进行远程服务调用；  
5 服务调用方和服务提供方定时向监控中心发送服务调用次数及调用时间等信息。  


#### RMI 的原理及应用(Remote Method Invocation)
RMI 是一个基于 Java 环境的应用编程接口，能够让本地 Java 虚拟机上运行的对象，像调用本地对象一样调用远程 Java 虚拟机上的对象。

RMI 可以说是 RPC 的一种具体形式，其原理与 RPC 基本一致，唯一不同的是 `RMI 是基于对象的，充分利用了面向对象的思想去实现整个
过程，其本质就是一种基于对象的 RPC 实现`。

#### 发布订阅
Kafka 是一种典型的发布订阅消息系统，其系统架构也是包括生产者、消费者和消息中心三部分。
+ 生产者（Producer）负责发布消息到消息中心，比如电子论文的会议方或出版社；
+ 消费者（Consumer）向消息中心订阅自己感兴趣的消息，获得数据后进行数据处理，比如订阅电子论文的老师或学生；
+ 消息中心（Broker）负责存储生产者发布的消息和管理消费者订阅信息，根据消费者订阅信息，将消息推送给消费者，比如论文网站。在 Kafka 中，消息中心本质上就是一组服务器，也可以说是 Kafka 集群。

Kafka 中除了 Producer、Broker、Consumer 之外，还有一个 ZooKeeper 集群。Zookeeper 集群用来协调和管理 Broker 和 Consumer，实现了 Broker 和 Consumer 的解耦，并为系统提供可靠性保证。

#### 消息队列
在实际使用场景中，还有一种常用的通信方式，就是将消息或数据放到一个队列里，谁需要谁就去队列里面取。在分布式领域中，这种模式叫“消息队列”。与发布订阅相比，消息队列技术的核心思想可以概括为“货物自取”

消息队列模式也是包括 3 个核心部分：
+ 生产者。生产者会产生消息或数据，并将消息或数据插入到消息队列中。
+ 消息队列。一种具有先进先出特点的数据结构，用于存储消息
+ 消费者。从消息队列中获取消息或数据，进行相关处理。













