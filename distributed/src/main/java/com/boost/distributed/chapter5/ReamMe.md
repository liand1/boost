#### 远程调用
通过一个例子，来让你对远程调用和本地调用有一个直观了解。

以电商购物平台为例，每一笔交易都涉及订单系统、支付系统及库存系统，假设三个系统分别部署在三台机器 A、B、C 中独立运行，订单交易流程如下所示：
1 用户下单时，调用本地（机器 A）的订单系统进行下单；  
2 下单完成后，会远程调用机器 B 上的支付系统进行支付，待支付完成后返回结果，之后在本地更新订单状态；  
3 在本地远程调用机器 C 上的仓库系统出货，出货完成后返回出货结果。

在整个过程中，“下单”和“订单状态更新”两个操作属于本地调用，而“支付”和“出货”这两个操作是通过本地的订单系统调用其他两个机器上的函数（方法）实现的，属于远程调用。

`本地调用`通常指的是，进程内函数之间的相互调用；而`远程调用`,是进程间函数的相互调用，是进程间通信 IPC（Inter-Process Communication）的一种方式.  
通过远程调用，一个进程可以看到其他进程的函数、方法等

`根据进程是否部署在同一台机器上，远程调用可以分为如下两类`：
+ 本地过程调用（Local Procedure Call，LPC）
> 是指运行在同一台机器上的进程之间的互相通信，即在多进程操作系统中，运行的不同进程之间可以通过 LPC 进行函数调用。
+ 远程过程调用（Remote Procedure Call，RPC）
> 是指不同机器中运行的进程之间的相互通信，某一机器上运行的进程在不知道底层通信细节的情况下，就像访问本地服务一样，去调用远程机器上的服务

##### 远程调用的原理及应用
我们经常会听别人提起 B/S ( Browser/Server，浏览器 / 服务器) 架构。在这种架构中，被调用方（服务器）有一个开放的接口，然后调用
方（用户）通过 Browser 使用这个接口，来间接调用被调用方相应的服务，从而实现远程调用。

比如，用户 A 在自己的电脑上通过浏览器查询北京今天的天气， 浏览器会将用户查询请求通过远程调用方式调用远程服务器相应的服务，然后为用户返回北京今天的天气预报。

但是，`B/S 架构是基于 HTTP 协议实现的，每次调用接口时，都需要先进行 HTTP 请求`。这样既繁琐又浪费时间，不适用于有低时延要求的大规模分布式系统，所以远程调用的实现大多采用更底层的网络通信协议。

两种常用的远程调用机制：`远程过程调用` RPC(Remote Procedure Call) 和`远程方法调用 RMI`(Remote Method Invocation)。

#### RPC 的原理及应用
简单地说，RPC 就是调用方采用参数传递的方式，通过调用本机器上的一个函数或方法，去执行远程机器上的函数或方法（可以统称为服务），并返回结果。在整个过程中，RPC 会隐藏具体的通信细节。

订单系统进程并不需要知道底层是如何传输的，在用户眼里，远程过程调用和调用一次本地服务没什么不同。这，就是 RPC 的核心。

+ 第一个区别是，调用 ID 和函数的映射。
> 在本地调用中，进程内可共享内存地址空间，因此程序可直接通过函数名来调用函数。 但在 RPC 中，只通过函数名是不行的，因为不同进程的地址空间是不一样的。
> 
> 所以在 RPC 中，所有的函数必须要有一个调用 ID 来唯一标识。一个机器上运行的进程在做远程过程调用时，必须附上这个调用 ID。
> 另外，我们还需要在通信的两台机器间，分别维护一个函数与调用 ID 的映射表。两台机器维护的表中，相同的函数对应的调用 ID 必须保持一致。
>
> 当一台机器 A 上运行的进程 P 需要远程调用时，它就先查一下机器 A 维护的映射表，找出对应的调用 ID，然后把它传到另一台机器 B 上，机器 B 通过查看它维护的映射表，从而确定进程 P 需要调用的函数，然后执行对应的代码，最后将执行结果返回到进程 P。

+ 第二个区别是，序列化和反序列化。
> 在本地调用中，进程之间共享内存等，因此我们只需要把参数压到栈里，然后进程自己去栈里读取就行。但是在 RPC 中，两个进程分布在不同的机器上，使用的是不同机器的内存，因此不可能通过内存来传递参数。
>
> 而网络协议传输的内容是二进制流，无法直接传输参数的类型，因此这就需要调用方把参数先转成一个二进制流，传到被调用方后，被调用方再把二进制流转换成自己能读取的格式。这个过程，就叫作序列化和反序列化。
> 同理，被调用方返回的结果也需要有序列化和反序列化的过程，不然调用方无法获取到结果

+ 第三个区别是，网络传输协议。
> 序列化和反序列化解决了调用方和被调用方之间的数据传输格式问题，但要想序列化后的数据能在网络中顺利传输，还需要有相应的网络协议，比如 TCP、UDP 等，因此就需要有一个底层通信层。
>
> 用方通过该通信层把调用 ID 和序列化后的参数传给被调用方，被调用方同样需要该通信层将序列化后的调用结果返回到调用方。
>
> 也就是说，只要调用方和被调用方可以互传数据，就可以作为这个底层通信层。因此，它所使用的网络协议可以有很多，只要能完成网络传输即可。目前来看，`大部分 RPC 框架采用的是 TCP 协议`。

`以一个具有代表性的 RPC 框架 Apache Dubbo 为例`
Dubbo 的架构主要包括 4 部分：
+ 服务提供方。服务提供方会向服务注册中心注册自己提供的服务。
+ 服务注册中心。服务注册与发现中心，负责存储和管理服务提供方注册的服务信息和服务调用方订阅的服务类型等。
+ 服务调用方。根据服务注册中心返回的服务所在的地址列表，通过远程调用访问远程服务。
+ 监控中心。统计服务的调用次数和调用时间等信息的监控中心，以方便进行服务管理或服务失败分析等。

Dubbo 的大致工作流程如下：
1 服务提供方需要向服务注册中心注册自己提供的服务；  
2 服务调用方需要向注册中心预订调用服务的提供方地址列表；
3 服务注册中心将服务对应的提供方地址列表返回给调用方；
4 服务调用方根据服务地址信息进行远程服务调用；
5 服务调用方和服务提供方定时向监控中心发送服务调用次数及调用时间等信息。









