### 分而治之(Divide-and-Conquer)
分治法就是将一个复杂的、难以直接解决的大问题，分割成一些规模较小的、可以比较简单的或直接求解的子问题，这些子问题之间相互独立且
与原问题形式相同，递归地求解这些子问题，然后将子问题的解合并得到原问题的解

比如，现在要统计全中国的人口数，由于中国的人口规模很大，如果让工作人员依次统计每个省市的人口数，工作量会非常大。在实际统计
中，我们通常会按照省分别统计，比如湖南省的工作人员统计湖南省的人口数，湖北省的工作人员统计湖北省的人口数等，然后汇总各个
省的人口数，即可得到全国人口数。

`在分布式领域，具体有哪些问题适合采用分治法呢?`
+ 问题规模比较大或复杂，且问题可以分解为几个规模较小的、简单的同类型问题进行求解；
+ 子问题之间相互独立，不包含公共子问题；
+ 子问题的解可以合并得到原问题的解。

`采用分治法解决问题的核心步骤是`：
+ 分解原问题。将原问题分解为若干个规模较小，相互独立，且与原问题形式相同的子问题
+ 求解子问题。若子问题规模较小且容易被解决则直接求解，否则递归地求解各个子问题。
+ 合并解，就是将各个子问题的解合并为原问题的解。

#### MapReduce
MapReduce 分为 Map 和 Reduce 两个核心阶段，其中 Map 对应“分”，即把复杂的任务分解为若干个“简单的任务”执行；Reduce 对应着“合”，即对 Map 阶段的结果进行汇总。

MapReduce，是一种批量计算的形式。这种模式下，会先收集数据并将其缓存起来，等到缓存写满时才开始处理数据。因此，批量计算的一个缺点就是，从数据采集到得到计算结果之间经历的时间很长。

-----------

#### Stream
近年来，由于网络监控、传感监测、AR/VR 等实时性应用的兴起，一类需要处理流数据的业务发展了起来。比如各种直播平台中，我们需要处理直播产生的音视频数据流等。这种如流水般持续涌现，且需要实时处理的数据，我们称之为`流数据`。

总结来讲，流数据的特征主要包括以下 4 点：
+ 数据如流水般持续、快速地到达；
+ 海量数据规模，数据量可达到 TB 级甚至 PB 级；
+ 对实时性要求高，随着时间流逝，数据的价值会大幅降低
+ 数据顺序无法保证，也就是说系统无法控制将要处理的数据元素的顺序。

在分布式领域中，处理流数据的计算模式，就是`流计算，也叫作 Stream`。

它是一个对实时性要求非常高的计算形式，如果数据处理不及时，很容易导致过时、没用的结果，这时就需要对造成的后果进行“背锅”。从这个角度来说，Stream 可谓“一门背锅的艺术”

类比于水流的持续不断且变幻莫测，流数据也是以大量、快速、时变的流形式持续在应用中产生，因此`流计算一般用于处理数据密集型应用`。

比如，百度、淘宝等大型网站中，每天都会产生大量的流数据，这些数据包括用户的搜索内容、用户的浏览记录等。实时采集用户数据，并通过流计算进行实时数据分析，可以了解每个时刻数据流的变化情况，甚至可以分析用户的实时浏览轨迹，从而进行个性化内容实时推荐，提高用户体验。  
此外，我们常用的爱奇艺、腾讯等音视频平台，对电影、电视剧等数据的处理，也是采用了流计算模式。

##### Stream 工作原理
流计算强调的是实时性，数据一旦产生就会被立即处理，当一条数据被处理完成后，会序列化存储到缓存中，然后立刻通过网络传输到下一个节
点，由下一个节点继续处理，而不是像 MapReduce 那样，等到缓存写满才开始处理、传输。为了保证数据的实时性，在流计算中，不会存储任
何数据，就像水流一样滚滚向前。

使用流计算进行数据处理，一般包括 3 个步骤:
+ 第一步，提交流式计算作业。
> 流式计算作业是一种常驻计算服务，比如实时交通监测服务、实时天气预报服务等。对于流式计算作业，首先必须预先定义计算逻辑，并提交
>到流计算系统中，使得流计算系统知道自己该如何处理数据。
>
>系统在整个运行期间，由于收集的是同一类型的数据、执行的是同一种服务，因此流式计算作业的处理逻辑不可更改。如果用户停止当前作
>业运行后再次提交作业，由于流计算不提供数据存储服务，因此之前已经计算完成的数据无法重新再次计算。
+ 第二步，加载流式数据进行流计算.
> 式计算作业一旦启动将一直处于等待事件触发的状态，一旦有小批量数据进入流式数据存储，系统会立刻执行计算逻辑并迅速得到结果。  
>在流计算系统中，有多个流处理节点，流处理节点会对数据进行预定义的处理操作，并在处理完后按照某种规则转发给后续节点继续处理。
>此外，流计算系统中还存在管理节点，主要负责管理处理节点以及数据的流动规则。其中，处理节点的个数以及数据转发的规则，都在第一步作业提交时定义。
+ 第三步，持续输出计算结果。
> 流式计算作业在得到小批量数据的计算结果后，可以立刻将结果数据写入在线 / 批量系统，无需等待整体数据的计算结果，以进一步做到实时计算结果的实时展现。

流计算不提供流式数据的存储服务，数据是持续流动的，在计算完成后就会立刻丢弃。流计算适用于需要处理持续到达的流数据、对数据处
理有较高实时性要求的场景。为了及时处理流数据，流计算框架必须是低延迟、可扩展、高可靠的。

流计算的应用场景有很多，比如它是网络监控、传感监测、AR/VR、音视频流等实时应用的发展的基础.所以，目前流计算相关的框架和平台也有很多了，主流的划分方式是将其分为如下 3 类：
+ 商业级的流计算平台，比如 IBM 的 InfoSphere Streams 和 TIBCO 的 StreamBase。
+ 开源流计算框架，典型代表是 Apache Storm（由 Twitter 开源）和 S4（由 Yahoo 开源）
+ 各大公司根据自身业务特点而开发的流计算框架，比如 Facebook 的 Puma、百度的 Dstream（旨在处理有向无环的数据流）、淘宝的银河流数据处理平台（一个通用的、低延迟、高吞吐、可复用的流数据实时计算系统）。

除了这些框架外，我们还会经常听到 Spark、Flink 等

#### Actor
Actor 模型，代表一种分布式并行计算模型。这种模型有自己的一套规则，规定了 Actor 的内部计算逻辑，以及多个 Actor 之间的通信规则。
在 Actor 模型里，每个 Actor 相当于系统中的一个组件，都是基本的计算单元。

`Actor 模型的计算方式与传统面向对象编程模型（Object-Oriented Programming，OOP）类似`，一个对象接收到一个方法的调用
请求（类似于一个消息），从而去执行该方法。

Actor 模式采用了异步模式，并且每个 Actor 封装了自己的数据、方法等，解决了 OOP 存在的死锁、竞争等问题。

Actor 模型还存在如下一些不足之处：
+ Actor 提供了模块和封装，但缺少继承和分层，这使得即使多个 Actor 之间有公共逻辑或代码部分，都必须在每个 Actor 中重写这部分代码，也就是说重用性小，业务逻辑的改变会导致整体代码的重写。
+ Actor 可以动态创建多个 Actor，使得整个 Actor 模型的行为不断变化，因此在工程中不易实现 Actor 模型。此外，增加 Actor 的同时，也会增加系统开销。
+ Actor 模型不适用于对消息处理顺序有严格要求的系统。因为在 Actor 模型中，消息均为异步消息，无法确定每个消息的执行顺序。虽然可以通过阻塞 Actor 去解决顺序问题，但显然，会严重影响 Actor 模型的任务处理效率。

Akka。Akka 是一个为 Java 和 Scala 构建高度并发、分布式和弹性的消息驱动应用程序的工具包。Akka 框架基于 Actor 模型，提供了一个用于构建可扩展的、弹性的、快速响应的应用程序的平台。  
Quasar (Java) 。Quasar 是一个开源的 JVM 库，极大地简化了高度并发软件的创建。Quasar 在线程实现时，参考了 Actor 模型，采用异步编程逻辑，从而为 JVM 提供了高性能、轻量级的线程，可以用在 Java 和 Kotlin 编程语言中。

#### 流水线模式
在现实生活中，经常还会出现这样的情况，前一个任务的结果是另外一个任务的输入。比如工厂生产一瓶饮料，首先需要往瓶子里装上饮料，待饮料装满后，再封口

`在分布式领域中解决类似具有依赖关系的流水线作业的计算模式，叫作流水线计算模式。`

##### 流水线计算模式的原理
Tensorflow 是 Google 开源的一个分布式机器学习框架, 以 TensorFlow 的输入流水线模式为例，介绍流水线技术模式的原理,了解如何构建机器学习的流水线。
其数据输入流水线主要包含 3 个步骤:
+ 提取（Extract）
> 通过多种途径读取数据，比如内存、本地的 HDD 或 SSD、远程的 HDFS、GCS 等。数据的种类也有很多，比如图像数据、文本数据、视频数据等。
+ 转换（Transform)
> 使用 CPU 处理器对输入的数据进行解析以及预处理操作，包括混合重排（shuffling）、批处理（batching）, 以及一些特定的转换。比如图像解压缩和扩充、文本矢量化、视频时序采样等。
+ 加载（Load）
> 将转换后的数据加载到执行机器学习模型的加速器设备上，比如 GPU 或 TPU。

