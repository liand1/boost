### 什么是负载均衡？
假设现在只有一个窗口、一个收银员：
1 一般情况下，收银员平均 2 分钟服务一位顾客，10 分钟可以服务 5 位顾客；  
2 到周末高峰期时，收银员加快收银，平均 1 分钟服务一位顾客，10 分钟最多服务 10 位顾客，也就是说一个顾客最多等待 10 分钟；  
3 逢年过节，顾客数量激增，一下增加到 30 位顾客，如果仍然只有一个窗口和一个收银员，那么所有顾客就只能排队等候了，一个顾客最多需要等待 30 分钟。这样购物体验，就非常差了。  

当然有。那就是新开一个收银窗口，每个收银窗口服务 15 个顾客，这样最长等待时间从 30 分钟缩短到 15 分钟。但如果，这两个窗口的排
队顾客数严重不均衡，比如一个窗口有 5 个顾客排队，另一个窗口却有 25 个顾客排队，就不能最大化地提升顾客的购物体验。  

通常情况下，`负载均衡可以分为两种`：
+ 一种是请求负载均衡，即将用户的请求均衡地分发到不同的服务器进行处理；  
+ 另一种是数据负载均衡，即将用户更新的数据分发到不同的存储服务器。  

#### 服务请求的负载均衡方法
> 通常情况下，计算机领域中，在不同层有不同的负载均衡方法。比如，从`网络层的角度`，通常有基于 DNS、IP 报文等的负载均衡方法；`在
> 中间件层`（也就是我们专栏主要讲的分布式系统层），常见的负载均衡策略主要包括轮询策略、随机策略、哈希和一致性哈希等策略
##### 轮询策略
轮询策略是一种实现简单，却很常用的负载均衡策略，核心思想是服务器轮流处理用户请求，以尽可能使每个服务器处理的请求数相同。生活中
也有很多类似的场景，比如，学校宿舍里，学生每周轮流打扫卫生，就是一个典型的轮询策略

###### 在负载均衡领域中，轮询策略主要包括顺序轮询和加权轮询两种方式。
+ 顺序轮询 
> 假设有 6 个请求，编号为请求 1~6，有 3 台服务器可以处理请求，编号为服务器 1~3，如果采用顺序轮询策略，则会按照服务器 1、2、3 的顺序轮流进行请求。
> 将 6 个请求当成 6 个步骤
```
> 1 请求 1 由服务器 1 处理
> 2 请求 2 由服务器 2 处理。
> 3 请求 3 由服务器 3 处理
> 4 请求 4 由服务器 1 处理
> 5 请求 5 由服务器 2 处理
> 6 请求 6 由服务器 3 处理
```

+ 加权轮询
加权轮询为每个服务器设置了优先级，每次请求过来时会挑选优先级最高的服务器进行处理。比如服务器 1~3 分配了优先级{4，1，1}，这 6 个请求到来时，还当成 6 个步骤，如表所示。
```
> 1 {4，1，1}请求 1 由优先级最高的服务器 1 处理，服务器 1 的优先级相应减 1，此时各服务器优先级为{3，1，1}；
> 2 {3，1，1}请求 1 由优先级最高的服务器 1 处理，服务器 1 的优先级相应减 1，此时各服务器优先级为{2，1，1}；
> 3 {2，1，1}请求 1 由优先级最高的服务器 1 处理，服务器 1 的优先级相应减 1，此时各服务器优先级为{1，1，1}；
> 4 {1，1，1}请求 1 由优先级最高的服务器 1 处理，服务器 1 的优先级相应减 1，此时各服务器优先级为{0，1，1}；
> 5 {0，1，1}请求 1 由优先级最高的服务器 1 处理，服务器 2 的优先级相应减 1，此时各服务器优先级为{0，0，1}；
> 6 {0，0，1}请求 1 由优先级最高的服务器 1 处理，服务器 3 的优先级相应减 1，此时各服务器优先级为{0，0，0}；
```

 `Nginx 默认的负载均衡策略就是一种改进的加权轮询策略, 解释下 Nginx 轮询策略需要用到的变量`
 1 weight：配置文件中为每个服务节点设置的服务节点权重，固定不变  
 2 effective_weight: 服务节点的有效权重，初始值为 weight。 在 Nginx 的源码中有一个最大失败数的变量 max_fails，当服务发生异
 常时，则减少相应服务节点的有效权重, 公式为 effective_weight = effective_weight - weight / max_fails,  之后再次选取本节点，
 若服务调用成功，则增加有效权重，effective_weight ++ ，直至恢复到 weight  
 3 current_weight: 服务节点当前权重，初始值均为 0，之后会根据系统运行情况动态变化。  
 
 假设，各服务器的优先级是{4，1，1}，还是将 6 个请求分为 6 步来进行讲解
 ```
> 1 遍历集群中所有服务节点，使用 current_weight = current_weight + effective_weight，计算此时每个服务节点的 current_weight，
  得到 current_weight 为{4，1，1}, total 为 4+1+1=6, 选出 current_weight 值最大的服务节点即服务器 1 来处理请求, 随后服务器 1 
  对应的 current_weight 减去此时的 total 值，即 4 - 6，变为了 -2 。
> 2 按照上述步骤执行，首先遍历，按照 current_weight = current_weight + effective_weight 计算每个服务节点 current_weight 的
 值，结果为{2，2，2}，total 为 6，选出 current_weight 值最大的服务节点。current_weight 最大值有多个服务节点时，直接选择第一个
 节点即可，在这里选择服务器 1 来处理请求，随后服务器 1 对应的 current_weight 值减去此时的 total，即 2 - 6，结果为 -4
> 3 

```
 
 
 



