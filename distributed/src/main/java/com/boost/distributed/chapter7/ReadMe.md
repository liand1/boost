### 什么是负载均衡？
假设现在只有一个窗口、一个收银员：
1 一般情况下，收银员平均 2 分钟服务一位顾客，10 分钟可以服务 5 位顾客；  
2 到周末高峰期时，收银员加快收银，平均 1 分钟服务一位顾客，10 分钟最多服务 10 位顾客，也就是说一个顾客最多等待 10 分钟；  
3 逢年过节，顾客数量激增，一下增加到 30 位顾客，如果仍然只有一个窗口和一个收银员，那么所有顾客就只能排队等候了，一个顾客最多需要等待 30 分钟。这样购物体验，就非常差了。  

当然有。那就是新开一个收银窗口，每个收银窗口服务 15 个顾客，这样最长等待时间从 30 分钟缩短到 15 分钟。但如果，这两个窗口的排
队顾客数严重不均衡，比如一个窗口有 5 个顾客排队，另一个窗口却有 25 个顾客排队，就不能最大化地提升顾客的购物体验。  

通常情况下，`负载均衡可以分为两种`：
+ 一种是请求负载均衡，即将用户的请求均衡地分发到不同的服务器进行处理；  
+ 另一种是数据负载均衡，即将用户更新的数据分发到不同的存储服务器。  

#### 服务请求的负载均衡方法
> 通常情况下，计算机领域中，在不同层有不同的负载均衡方法。比如，从`网络层的角度`，通常有基于 DNS、IP 报文等的负载均衡方法；`在
> 中间件层`（也就是我们专栏主要讲的分布式系统层），常见的负载均衡策略主要包括轮询策略、随机策略、哈希和一致性哈希等策略
##### 轮询策略
轮询策略是一种实现简单，却很常用的负载均衡策略，核心思想是服务器轮流处理用户请求，以尽可能使每个服务器处理的请求数相同。生活中
也有很多类似的场景，比如，学校宿舍里，学生每周轮流打扫卫生，就是一个典型的轮询策略

###### 在负载均衡领域中，轮询策略主要包括顺序轮询和加权轮询两种方式。
+ 顺序轮询 
> 假设有 6 个请求，编号为请求 1~6，有 3 台服务器可以处理请求，编号为服务器 1~3，如果采用顺序轮询策略，则会按照服务器 1、2、3 的顺序轮流进行请求。
> 将 6 个请求当成 6 个步骤
```
> 1 请求 1 由服务器 1 处理
> 2 请求 2 由服务器 2 处理。
> 3 请求 3 由服务器 3 处理
> 4 请求 4 由服务器 1 处理
> 5 请求 5 由服务器 2 处理
> 6 请求 6 由服务器 3 处理
```

+ 加权轮询
加权轮询为每个服务器设置了优先级，每次请求过来时会挑选优先级最高的服务器进行处理。比如服务器 1~3 分配了优先级{4，1，1}，这 6 个请求到来时，还当成 6 个步骤，如表所示。
```
> 1 {4，1，1}请求 1 由优先级最高的服务器 1 处理，服务器 1 的优先级相应减 1，此时各服务器优先级为{3，1，1}；
> 2 {3，1，1}请求 1 由优先级最高的服务器 1 处理，服务器 1 的优先级相应减 1，此时各服务器优先级为{2，1，1}；
> 3 {2，1，1}请求 1 由优先级最高的服务器 1 处理，服务器 1 的优先级相应减 1，此时各服务器优先级为{1，1，1}；
> 4 {1，1，1}请求 1 由优先级最高的服务器 1 处理，服务器 1 的优先级相应减 1，此时各服务器优先级为{0，1，1}；
> 5 {0，1，1}请求 1 由优先级最高的服务器 1 处理，服务器 2 的优先级相应减 1，此时各服务器优先级为{0，0，1}；
> 6 {0，0，1}请求 1 由优先级最高的服务器 1 处理，服务器 3 的优先级相应减 1，此时各服务器优先级为{0，0，0}；
```

+ Nginx 平滑的加权轮询策略
 `Nginx 默认的负载均衡策略就是一种改进的加权轮询策略, 解释下 Nginx 轮询策略需要用到的变量`
 1 weight：配置文件中为每个服务节点设置的服务节点权重，固定不变  
 2 effective_weight: 服务节点的有效权重，初始值为 weight。 在 Nginx 的源码中有一个最大失败数的变量 max_fails，当服务发生异
 常时，则减少相应服务节点的有效权重, 公式为 effective_weight = effective_weight - weight / max_fails,  之后再次选取本节点，
 若服务调用成功，则增加有效权重，effective_weight ++ ，直至恢复到 weight  
 3 current_weight: 服务节点当前权重，初始值均为 0，之后会根据系统运行情况动态变化。  
 
 假设，各服务器的优先级是{4，1，1}，还是将 6 个请求分为 6 步来进行讲解
 ```
> 1 遍历集群中所有服务节点，使用 current_weight = current_weight + effective_weight，计算此时每个服务节点的 current_weight，
  得到 current_weight 为{4，1，1}, total 为 4+1+1=6, 选出 current_weight 值最大的服务节点即服务器 1 来处理请求, 随后服务器 1 
  对应的 current_weight 减去此时的 total 值，即 4 - 6，变为了 -2 。{-2， 1， 1}
> 2 按照上述步骤执行，首先遍历，按照 current_weight = current_weight + effective_weight 计算每个服务节点 current_weight 的
 值，结果为{2，2，2}`(源于{-2, 1, 1} + {4, 1, 1})`，total 为 6，选出 current_weight 值最大的服务节点。current_weight 最大值有多个服务节点时，直接选择第一个
 节点即可，在这里选择服务器 1 来处理请求，随后服务器 1 对应的 current_weight 值减去此时的 total，即 2 - 6，结果为 -4, {-4, 2, 2}
> 3 {0, 3, 3}`(源于{-4, 2, 2} + {4, 1, 1})`, 服务器2处理请求， current_weight值减去此时的 total 6， {0， -3， 3}
> 4 {4, -2, 4}`(源于{0， -3， 3} + {4, 1, 1})`, 服务器1处理请求,current_weight值减去此时的 total 6, {-2, -2, 4}
> 5 {2, -1, 5}`(源于{-2, -2, 4} + {4, 1, 1})`, 服务器3处理请求,current_weight值减去此时的 total 6, {2, -1, -1}
> 6 {6, 0, 0}`(源于{2, -1, -1} + {4, 1, 1})`, 服务器1处理请求,current_weight值减去此时的 total 6, {0, 0, 0}
```

可以看到，与普通的加权轮询策略相比，这种轮询策略的优势在于，当部分请求到来时，不会集中落在优先级较高的那个服务节点。

还是上面的例子，假设只有 4 个请求，按照普通的加权轮询策略，会全部由服务器 1 进行处理，即{1,1,1,1}；而按照这种平滑的加权轮询
策略的话，会由服务器 1 和 2 共同进行处理，即{1,1,2,1}。

`轮询策略的优点`就是，实现简单，且对于请求所需开销差不多时，负载均衡效果比较明显，同时加权轮询策略还考虑了服务器节点的异构性，即可
以让性能更好的服务器具有更高的优先级，从而可以处理更多的请求，使得分布更加均衡。

`轮询策略的缺点`是，每次请求到达的目的节点不确定，不适用于有状态请求的场景。并且，轮询策略主要强调请求数的均衡性，所以不适用于处理
请求所需开销不同的场景。 <font color='red'>`综上所述，轮询策略适用于用户请求所需资源比较接近的场景`</font>。

+ 随机策略
随机策略也比较容易理解，指的就是当用户请求到来时，会随机发到某个服务节点进行处理，可以采用随机函数实现。这里，随机函数的作用就
是，让请求尽可能分散到不同节点，防止所有请求放到同一节点或少量几个节点上。

`随机策略适用于，集群中服务器节点处理能力相差不大，用户请求所需资源比较接近的场景`。

+ 哈希和一致性哈希策略
`哈希与一致性策略的优点是`，哈希函数设置合理的话，负载会比较均衡。而且，相同 key 的请求会落在同一个服务节点上，可以用于有状态请求的
场景。除此之外，带虚拟节点的一致性哈希策略还可以解决服务器节点异构的问题。

`但其缺点是`，当某个节点出现故障时，采用哈希策略会出现数据大规模迁移的情况，采用一致性哈希策略可能会造成一定的数据倾斜问题。同
样的，这两种策略也没考虑请求开销不同造成的不均衡问题。





 
 
 



