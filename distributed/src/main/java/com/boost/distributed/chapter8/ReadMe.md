### 铁路局发布火车票
购买火车票的流程做了一个简化，大致划分为三大核心步骤：
+ 首先，铁路局向购票系统发布火车票；
+ 然后，用户通过系统查询火车票，找到需要的火车票后购买；
+ 最后，购票系统给用户响应，完成购票。

#### 铁路局发布火车票
铁路局发布火车票的过程，主要涉及分布式数据存储这一站的知识，`包括存储系统三要素、数据分布和数据复制`等技术。

铁路局向购票系统发布火车票的过程，主要是将火车票信息发送到服务器集群进行存储，需要用到`存储系统三要素`的相关技术。其中，铁路局就
是存储系统三要素中的“顾客”，火车票存储到具体哪个服务器需要构建数据索引，也就是我们说的三要素中的“导购”，而存储数据的服务器就是三
要素中的“货架”。

由于涉及多个服务器存储火车票信息，不可避免地需要考虑服务器之间数据存储的均衡，以及快速确定火车票信息存储位置以方便后续查询和购买
火车票。因此，这里需要用到`分布式存储中的数据分布技术`。

铁路局按照火车线路将火车票发布到不同的服务器上，即在`数据分片技术`中提到的按照数据范围进行分片。比如，京广线的车票信息存储在京广
线服务器集群、京沪线的车票信息存储在京沪线服务器集群等。

除此之外，为了保证可靠性，也就是当一台服务器故障后，该服务器存储的火车票信息可以恢复或不丢失，通常会进行数据备份。也就是说，同
一份数据可能会有多台服务器一起存储，比如京广线的火车票数据存储到服务器 A1、A2 和 A3 上，京沪线的火车票数据存储在服务器 B1、B2 和 B3 上。

而数据备份，用到的就是分布式存储中的`数据复制`技术。由于同一份数据被多台服务器存储，自然就需要保证数据的一致性。关于数据一致性，你可以参考`CAP 理论`这篇文章。

#### 用户查询火车票
对于用户查询火车票来说，大致过程是用户向服务器发起查询请求，服务器根据用户请求，通过数据索引，也就是`导购`技术，定位到火车票信息
存储的位置，然后获取数据返回给用户。

从这个流程可以看出，`服务器接收用户查询请求是第一步`。

正常情况下，用户并发请求量比较小，很少会出现服务器能力有限导致系统崩溃的情况。但，遇到节假日或春节，用户请求量通常会非常大，这
时如果不采取一定策略的话，大概率会因为服务器能力受限导致系统崩溃。

而这里的策略，通常就是保证分布式高可靠的负载均衡和流量控制。比如，每年春运，火车票发布的瞬间，就有大量的用户抢票，如果购票系
统后台不使用`负载均衡`和`流量控制`的话，服务器一下子就被击垮了

除此之外，服务器还不可避免地会出现一些小故障，比如磁盘损坏、网络故障等问题。如何检测服务器故障，以及如何进行故障恢复，就需要用到
分布式高可用的`故障隔离`与`故障恢复`的相关技术了。

接收用户请求后，接下来需要将请求转发至相应的服务器集群，然后再从中选择某一台服务器处理用户请求，也就是获取数据并返回给用户。本
质上，这就是在进行数据索引，设计分布式数据存储中的数据分布方式的相关技术。

以用户查询从北京到上海的火车票信息为例，查询流程如下：
+ 首先，根据查询条件，系统将请求转发至存储京沪线火车票信息的服务器集群中；
+ 然后，服务器集群再使用一次负载均衡，比如使用轮询算法， 将请求转发至某一台服务器；
+ 最后，这台服务器将火车票的车次、余票等信息返回给用户。

在这个过程中，还可以使用限流算法，比如`漏桶`、`令牌桶`等策略来限制用户流量，保证系统高可用。

除此之外，在存储火车票信息的服务器中，各个服务器的服务单独运行，也就相当于做了一定的故障隔离

当然，这里`还需要注意一个问题`。在上面的过程中，我一直提到的是服务器集群。既然是集群，就会涉及`集群架构`、`分布式选主`等策略。

以集中式架构 Master/Slave 为例，服务器集群中会通过分布式选举算法选出一个 Master，Master 和其他服务器节点之间会维持心跳，并
通过心跳来感知服务器节点的存活状态。

当集群中 Master 节点故障后，会从其他节点中重新选举出一个 Master 节点，继续为用户提供服务，也就是备升主，以保证服务的可用性。
这里，备升主就是一种故障恢复策略。

#### 用户购买火车票
用户购买火车票的过程与用户查询火车票的过程非常相似，`唯一不同的是会造成数据库的变化`。

写请求与读请求的区别是，写请求会造成数据的变化，因此相对于查询火车票，购买火车票的过程涉及的技术问题会多一些，但多出的无非就是数
据的一致性问题。谈到数据的一致性，我们就会想到`CAP 理论`、`数据复制技术`、`分布式事务`、`分布式锁`等。

本质上讲，每次购买火车票的操作，就是一个分布式事务，要么执行成功要么执行失败。

当用户购买了火车票时，该火车票对应时间的车次余票数量必须相应减 1，如果减少时发现原先票数就已经为 0 了，此时就应该提醒用户购买火
车票失败，余票为 0；同样的，如果票数不为 0，则票数应该相应减 1，并提示用户购票成功。

不难看出，购买火车票会改变火车票数据，也不可避免地会存在多个用户同时购买相同路线、相同车次（比如京沪线的 T12）的场景。也就是说
，这个购买过程存在多个进程同时访问共享资源的问题，因此还要用到分布式锁的相关技术。

`用户购买火车票的过程还会涉及用户体验、数据一致性和网络故障等问题，因此还涉及 C、A、P 策略的选择问题`。

铁路局发布火车票的流程中，为了保证可靠性，同一数据通常会备份到多个服务器上。当用户购买火车票导致火车票数据改变时，主节点上的数据
必须与备节点上的数据保持一致，以防止主节点故障后，备升主，但数据不一致导致业务出错的情况

>比如，用户 A 购买 2019 年 10 月 12 日北京到上海的 T12 的火车票，已购买成功，座位号为 3 车厢 23B。假设主节点和备节点之间数据
>不一致，主节点上已经减去该火车票，但未在备节点上减去。此时，若主节点故障，备节点升主，用户 B 此时申请购买相同火车票，系统将 
>3 车厢 23B 火车票又卖给了用户 B。等到乘车时，用户 A 和 B 就难免“打架”了。

当然，通常因为网络故障或节点故障等原因导致主节点不能正常工作，才会发生备升主，而备升主其实就是故障恢复策略

同时，购买火车票的场景需要快速响应用户，以保证用户体验。因此，通常优先保证系统的可用性，稍微降低对数据一致性的要求，但也必须保证
最终一致性。这就是我们平常遇到的，查询火车票时还有余票，但下单后却提示余票为 0，无法购买。

导致这个结果的原因是，下单前你访问的数据库中，数据还未同步，显示有余票；而下单后，数据实现同步了，发现余票数量已经为 0，因此
提示你无法购买该火车票。

实现上述策略的方法，通常会采用半同步复制技术，即将修改后的数据同步到多个备数据库中的某一个或几个后立即响应用户，而不用将数据同步
到所有备数据库。

除此之外，业务量很大的情况下，为了让服务更加健壮、低耦合、便于管理，会根据功能拆分为不同的服务。比如，将整个购票系统拆分为订单
系统、支付系统和通知系统，而当购票系统拆分为 3 个子系统后，子系统之间不可避免的存在信息的交互，子系统之间的交互就会涉及分布式通信
的相关知识，比如远程调用 RPC、消息队列等

用户购买火车票后，会首先在订单系统下单，下单成功后会调用支付系统的支付操作进行支付，之后将支付成功的消息存放到消息队列中，通知
系统到消息队列中获取消息，最后通知用户购买成功。

