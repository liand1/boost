##本章内容
### 1.1 简介
  Docker是一个能够把开发的应用程序自动部署到容器的开源引擎。Docker在虚拟化的容器执行环境中增加了一个应用程序部署引擎。该
引擎的目标就是提供一个轻量，快速的环境，能够运行开发者的程序。基于Go语言

#### 1.1.1 提供一个简单，轻量的建模方式 
Docker依赖写时复制copy-on-write模型。
+ 基于容器的虚拟化，仅包含业务运行所需的runtime环境，CentOS/Ubuntu基础镜像仅170MB
```
 docker search centOS // 下载下来后可以查看大小，200MB左右，因为它精简了系统,比如硬件，打印等等，是一个最小的运行环境
```
+ 无操作系统虚拟化开销
#### 1.1.2 职责的逻辑分离。
开发人员只需要关心容器中运行的应用程序，运维只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码时的开发环境
与应用程序要部署的生产环境的一致性，从而降低那种“开发时一切正常，肯定是运维的问题”的风险。
#### 1.1.3 快速高效的开发生命周期
Docker的目标之一就是缩短代码从开发，测试到部署，上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。
#### 1.1.4 Docker鼓励面向服务的架构和微服务架构。
Docker推荐单个容器只运行一个应用程序或进程。这样就形成了一个分布式的应用程序模型。

### 1.2 组件
+ Docker客户端和服务器。
+ Docker镜像
+ Registry
+ Docker容器

#### 1.2.1 Docker客户端和服务器
Docker是一个客户-服务器(C/S)架构的程序。Docker客户端只需向Docker服务器或守护进程发出请求，服务器或守护进程将完成所有工
作并返回结果。Docker提供了一个命令行工具docker以及一整套RESTful API。你可以在同一台主机上运行Docker守护进程和客户端。也
可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。
#### 1.2.2 Docker镜像
镜像是构建Docker世界的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于
联合（Union）文件系统的一种层式的结构。，由一系列指令一步一步构建出来。例如：  
+ 添加一个文件  
+ 执行一个命令  
+ 打开一个端口  
  
也可以把镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享，存储和更新。 
Docker镜像就是一个`只读`的模板，镜像可以用来创建Docker容器，一个镜像可以创建很多容器。
`可以把镜像比作类，容器比作对象`。

>UnionFS: 联合文件系统，是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层叠加，同时
 可以将不同目录挂载到同一个虚拟文件系统下，UnionFS是docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)
 ，可以制作各种具体的应用镜像。
>Docker镜像加载原理：
 docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统叫UnionFS。
 bootfs(boot file system) 主要包含bootloader和kernel，bootloader 主要是引导加载kernel，Linux刚启动时会加载bootfs文件系
 统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整
 个内核就存在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。
 roorfs （root file system），在bootfs之上。包含的就是典型Linux系统中的 /dev ，/proc，/bin ，/etx 等标准的目录和文件。
 rootfs就是各种不同的操作系统发行版。比如Ubuntu，Centos等等。
 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host（宿主机）的kernel，
 自己只需要提供rootfs就行了，由此可见对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。

`我们在docker pull的时候可以看到下载了多个文件系统。我们pull tomcat的时候，镜像文件有400多MB，是因为tomcat有依赖环境，
 需要linux环境和JDK`，这样的好处就是可以共享资源。比如多个镜像都从相同的base镜像构建而来。多个镜像如果有相同的只会下载一次。
#### 1.2.3 Registry 仓库注册服务器
Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营的公共Registry叫做Docker Hub。用户可以
在Docker Hub注册帐号，分享并保存自己的镜像。根据最新统计，Docker Hub上有超过10000注册用户构建和分享的镜像。需要
Nginx web服务器的Docker镜像或者MySQL数据库的镜像？这些镜像在Docker Hub上都有，而且具有多种版本。你可以在Docker Hub上
保存自己的私有镜像，甚至可以架设自己的私有Registry。

存放镜像文件的场所
仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签(tag)
#### 1.2.4 Docker容器
Docker可以帮你构建和部署容器，你只需要把自己的应用程序或服务打包放进容器即可。我们刚刚提到，容器是基于镜像启动起来的，
容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或打包阶段，而容器则是启动或执行阶段。总结起
来，Docker容器就是：
+ 一个镜像格式； 
+ 一系列标准的操作； 
+ 一个执行环境； 

Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计哲学中，唯一不同的是：集装
箱运输货物，而Docker运输软件。每个容器都包含一个软件的镜像，也就是容器的“货物”，而且与真正的货物一样，可以对容器里
的软件镜像进行一些操作。例如，镜像可以被创建，启动，关闭，重启以及销毁。和集装箱一样，Docker在执行上述操作时，并不
关心容器中到底塞进了什么，它不管里面是web服务器，还是数据库，或者是应用程序服务器什么的。所有容器都按照相同的方式将
内容“装载”进去

可以把容器看成是一个简易版的linux环境(包括root用户权限，进程空间，用户空间和网络空间等)和运行在其中的应用程序。
只有通过镜像文件才能生成Docker容器。image文件可以看作是容器的模板。

`Docker 容器的能力`
+ 文件系统隔离：每个容器都有自己的root文件系统
+ 进程隔离： 每个容器都运行在自己的进程环境中
+ 网络隔离： 容器间的虚拟网络接口和IP地址都是分开的
+ 资源隔离和分组： 使用cgroup将cpu和内存之类的资源独立分配给每个docker容器

### 1.3 我们能用Docker做什么
+ 快速构建一个应用服务器，一个消息总线，一套实用工具，一个持续集成Jenkins CI 测试环境或者任意一种程序，服务或工具。
+ 加速本地开发和构建流程。容器可以在开发环境中构建，然后轻松地提交到测试环境中，并最终进入生产环境
+ 能够让独立服务或应用程序在不同的环境中，得到相同的运行结果。在SOA和微服务架构中尤其重要
+ 用Docker创建隔离的环境来进行测试。
+ 构建一个多用户的平台即服务PaaS基础设施
+ 为开发，测试，教学提供一个轻量级的独立沙盒环境。
+ 高性能，超大规模的宿主机部署

### 1.4 Docker与配置管理
  