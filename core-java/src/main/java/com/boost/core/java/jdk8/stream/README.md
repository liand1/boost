case1:   
case2: 流只能消费一次  
case3: 外部迭代和内部迭代， 中间操作与终端操作  
case4: 使用流, filter/distinct/limit/skip  
case5: 使用流, 映射， 流的扁平化(flatMap)  
case6: 查找和匹配 短路求值  
case7: 计算reduce  
case8: 应用场景  
case9: 数值流, 数值范围  
case10: 构建流, 流的创建方式   
Case11: 流的运行逻辑，本质上了解stream是怎么运行的  


和CollectionAPI相比，StreamAPI处理数据的方式非常不同.用集合的话，你得
自己去做迭代的过程.你得用for-each循环一个个去迭代元素，然后再处理元素.我们把这种
数据迭代的方法称为外部迭代.相反，有了StreamAPI，你根本用不着操心循环的事情.数据处
理完全是在库内部进行的.我们把这种思想叫作内部迭代

>Java中的并行与无共享可变状态
大家都说Java里面并行很难，而且和synchronized相关的玩意儿都容易出问题.那Java8
里面有什么“灵丹妙药”呢？事实上有两个.首先，库会负责分块，即把大的流分成几个小的
流，以便并行处理.其次，流提供的这个几乎免费的并行，只有在传递给filter之类的库方
法的方法不会互动（比方说有可变的共享对象）时才能工作.但是其实这个限制对于程序员来
说挺自然的，举个例子，我们的Apple::isGreenApple就是这样.确实，虽然函数式编程中
的函数的主要意思是“把函数作为一等值”，不过它也常常隐含着第二层意思，即“执行时在
元素之间无互动”.

### 流是什么
>流是Java API的新成员，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不
 是临时编写一个实现）。就现在来说，你可以把它们看成遍历数据集的高级迭代器。此外，**流
 还可以透明地并行处理，你无需写任何多线程代码了**

那么，流到底是什么呢？简短的定义就是“从支持数据处理操作的源生成的元素序列”。让
我们一步步剖析这个定义。

+ >元素序列——就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序
   值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元
   素（如ArrayList 与 LinkedList）。但流的目的在于表达计算，比如你前面见到的
   filter、sorted和map。集合讲的是数据，流讲的是计算。我们会在后面几节中详细解
   释这个思想。
  
+ > 源——流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集
    合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。
  
+ >  数据处理操作——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中
     的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执
     行，也可并行执行。   
  
+ > 此外，流操作有两个重要的特点。
     流水线——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大
    的流水线。这让我们下一章中的一些优化成为可能，如延迟和短路。流水线的操作可以
    看作对数据源进行数据库式查询。
     内部迭代——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的
  
### 流与集合
>Java现有的集合概念和新的流概念都提供了接口，来配合代表元素型有序值的数据接口。所
 谓有序，就是说我们一般是按顺序取用值，而不是随机取用的。那这两者有什么区别呢？
 我们先来打个直观的比方吧。比如说存在DVD里的电影，这就是一个集合（也许是字节，也
 许是帧，这个无所谓），因为它包含了整个数据结构。现在再来想想在互联网上通过视频流看同
 样的电影。现在这是一个流（字节流或帧流）。流媒体视频播放器只要提前下载用户观看位置的
 那几帧就可以了，这样不用等到流中大部分值计算出来，你就可以显示流的开始部分了（想想观
 看直播足球赛）。特别要注意，视频播放器可能没有将整个流作为集合，保存所需要的内存缓冲
 区——而且要是非得等到最后一帧出现才能开始看，那等待的时间就太长了。出于实现的考虑，
 你也可以让视频播放器把流的一部分缓存在集合里，但和概念上的差异不是一回事。
 粗略地说，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，
 它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。（你可
 以往集合里加东西或者删东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素
 都得先算出来才能成为集合的一部分。）
 相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计
 算的。 这对编程有很大的好处, 
>  流就像是一个延迟创建的集合：只有在消费者要求的时候才会计算值.与此相反，集合则是急
切创建的（供应商驱动：先把仓库装满，再开始卖，就像那些昙花一现的圣诞新玩意儿一样）。

### 只能遍历一次
 >请注意，和迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。
 你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集
 合之类的可重复的源，如果是I/O通道就没戏了）。

### 流由3部分组成
1 源
2 零个或多个中间操作
3 终止操作
### 流操作的分类
1 惰性求值
2 及早求值