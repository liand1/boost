case1~2: 正确使用并行流
case3: 分支/合并框架
case4: Spliterator
### 并行数据处理与性能  
本章内容
 用并行流并行处理数据
 并行流的性能分析
 分支/合并框架
 使用Spliterator分割流


#### 并行流  
> 并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。这样一来，你就可以自动把给定操作的工作负荷
分配给多核处理器的所有内核，让它们都忙起来。

#### 配置并行流使用的线程池  
> 并行流内部使用了默认的ForkJoinPool，它默认的
线程数量就是你的处理器数量，这个值是由 Runtime.getRuntime().availableProcessors()得到的。
但是你可以通过系统属性 java.util.concurrent.ForkJoinPool.common.
parallelism来改变线程池大小，如下所示：
System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism","12");
这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个
并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器数量是个不错的默认值，
除非你有很好的理由，否则我们强烈建议你不要修改它。

#### 高效使用并行流
+ > 如果有疑问，测量。把顺序流转成并行流轻而易举，但却不一定是好事。我们在本节中
已经指出，并行流并不总是比顺序流快。此外，并行流有时候会和你的直觉不一致，所
以在考虑选择顺序流还是并行流时，第一个也是最重要的建议就是用适当的基准来检查
其性能。

+ > 留意装箱。自动装箱和拆箱操作会大大降低性能。Java 8中有原始类型流（IntStream、
LongStream、DoubleStream）来避免这种操作，但凡有可能都应该用这些流。

+ > 有些操作本身在并行流上的性能就比顺序流差。特别是limit和findFirst等依赖于元
素顺序的操作，它们在并行流上执行的代价非常大。例如，findAny会比findFirst性
能好，因为它不一定要按顺序来执行。你总是可以调用unordered方法来把有序流变成
无序流。那么，如果你需要流中的n个元素而不是专门要前n个的话，对无序并行流调用
limit可能会比单个有序流（比如数据源是一个List）更高效。
 
+ > 还要考虑流的操作流水线的总计算成本。设N是要处理的元素的总数，Q是一个元素通过
流水线的大致处理成本，则N*Q就是这个对成本的一个粗略的定性估计。Q值较高就意味
着使用并行流时性能好的可能性比较大。  
 
+ > 对于较小的数据量，选择并行流几乎从来都不是一个好的决定。并行处理少数几个元素
的好处还抵不上并行化造成的额外开销。  
  
+ > 要考虑流背后的数据结构是否易于分解。例如，ArrayList的拆分效率比LinkedList
高得多，因为前者用不着遍历就可以平均拆分，而后者则必须遍历。另外，用range工厂
方法创建的原始类型流也可以快速分解。自己实现Spliterator来完全掌控分解过程。 
  
+ > 流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能。
例如，一个SIZED流可以分成大小相等的两部分，这样每个部分都可以比较高效地并行处
理，但筛选操作可能丢弃的元素个数却无法预测，导致流本身的大小未知。
  
+ > 还要考虑终端操作中合并步骤的代价是大是小（例如Collector中的combiner方法）。
如果这一步代价很大，那么组合每个子流产生的部分结果所付出的代价就可能会超出通
过并行流得到的性能提升。   
  
+ 流的数据源和可分解性

  源  | 可分解性    
  ---- | ----  
  ArrayList      |    极佳   
  LinkedList     |     差  
  IntStream.range|    极佳  
  Stream.iterate |     差  
  HashSet        |     好  
  TreeSet        |     好  
  
#### 使用分支/合并框架的最佳做法  
+ >虽然分支/合并框架还算简单易用，不幸的是它也很容易被误用。以下是几个有效使用它的
最佳做法。
+ > 对一个任务调用join方法会阻塞调用方，直到该任务做出结果。因此，有必要在两个子
    任务的计算都开始之后再调用它。否则，你得到的版本会比原始的顺序算法更慢更复杂，
    因为每个子任务都必须等待另一个子任务完成才能启动。
+ > 不应该在RecursiveTask内部使用ForkJoinPool的invoke方法。相反，你应该始终直
    接调用compute或fork方法，只有顺序代码才应该用invoke来启动并行计算。
+ > 对子任务调用fork方法可以把它排进ForkJoinPool。同时对左边和右边的子任务调用
    它似乎很自然，但这样做的效率要比直接对其中一个调用compute低。这样做你可以为
    其中一个子任务重用同一线程，从而避免在线程池中多分配一个任务造成的开销。
+ > 调试使用分支/合并框架的并行计算可能有点棘手。特别是你平常都在你喜欢的IDE里面
    看栈跟踪（stack trace）来找问题，但放在分支合并计算上就不行了，因为调用compute
    的线程并不是概念上的调用方，后者是调用fork的那个。
+ > 和并行流一样，你不应理所当然地认为在多核处理器上使用分支/合并框架就比顺序计
    算快。我们已经说过，一个任务可以分解成多个独立的子任务，才能让性能在并行化时
    有所提升。所有这些子任务的运行时间都应该比分出新任务所花的时间长；一个惯用方
    法是把输入/输出放在一个子任务里，计算放在另一个里，这样计算就可以和输入/输出
    同时进行。此外，在比较同一算法的顺序和并行版本的性能时还有别的因素要考虑。就
    像任何其他Java代码一样，分支/合并框架需要“预热”或者说要执行几遍才会被JIT编
    译器优化。这就是为什么在测量性能之前跑几遍程序很重要，我们的测试框架就是这么
    做的。同时还要知道，编译器内置的优化可能会为顺序版本带来一些优势（例如执行死
    码分析——删去从未被使用的计算）。 

#### 工作窃取
`分支/合并框架工程用一种称为工作窃取（work stealing）的技术来解决这个问题。在实际应
用中，这意味着这些任务差不多被平均分配到ForkJoinPool中的所有线程上。每个线程都为分
配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执
行。基于前面所述的原因，某个线程可能早早完成了分配给它的所有任务，也就是它的队列已经
空了，而其他的线程还很忙。这时，这个线程并没有闲下来，而是随机选了一个别的线程，从队
列的尾巴上“偷走”一个任务。这个过程一直继续下去，直到所有的任务都执行完毕，所有的队
列都清空。这就是为什么要划成许多小任务而不是少数几个大任务，这有助于更好地在工作线程
之间平衡负载`

#### Spliterator
> 了解这个拆分过程在内部是如何执行的
`拆分过程:将Stream拆分成多个部分的算法是一个递归过程。第一步是对第一个
     Spliterator调用trySplit，生成第二个Spliterator。第二步对这两个Spliterator调用
     trySplit，这样总共就有了四个Spliterator。这个框架不断对Spliterator调用trySplit
     直到它返回null，表明它处理的数据结构不能再分割，如第三步所示。最后，这个递归拆分过
     程到第四步就终止了，这时所有的Spliterator在调用trySplit时都返回了null。
这个拆分过程也受Spliterator本身的特性影响，而特性是通过characteristics方法声
明的。`
