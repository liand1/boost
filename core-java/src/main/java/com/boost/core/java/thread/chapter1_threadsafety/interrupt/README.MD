### 停止线程
    通常我们会有这样的需求，即停止一个线程。在java的api中有stop、suspend等方法可以达到目的，但由于这些方法在使用上存在不
    安全性，会带来不好的副作用，不建议被使用。[具体原因](https://docs.oracle.com/javase/6/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html)
    
### interrupt
    1.interrupt()
        其作用是中断此线程（此线程不一定是当前线程，而是指调用该方法的Thread实例所代表的线程），但实际上只是给线程设置一
        个中断标志，线程仍会继续运行。还需要加入一个判断才可以完成线程的停止。
        
    2.interrupted()
        作用是测试当前线程是否被中断（检查中断标志），返回一个boolean并清除中断状态，第二次再调用时中断状态已经被清除，
        将返回一个false。
        
    3.isInterrupted()
        作用是只测试此线程是否被中断 ，不清除中断状态。    
        
           
case1:调用interrupt方法不是真正的停止线程  
case2:判断线程是否是停止状态 interrupted  
case3:this.isInterrupted()测试线程Thread对象是否已经是中断状态，但不清除标志  
case4:要解决完全退出run方法的情况，这里我们采用了抛出InterruptedException  
case5:睡眠中中断线程  
case6:先中断线程，然后进入到sleep   

在多线程编程中，线程个数一般都大于cpu个数，而每个cpu同一时刻只能被一个线程使用，为了让用户感觉多个线程是在同时执行的,  
cpu资源采用了时间片轮转的策略，也就是给每一个线程分配一个时间片，线程在时间片内占用cpu执行任务。当前线程使用时间片之后，  
就会处于就绪状态并让出cpu让其他线程占用，这就是上下文切换，从当前线程的上下文切换到了其他线程。  
那么就有一个问题，让出cpu的线程等下次轮到自己占有cpu的时，如何知道自己之前运行到了哪里，所以在切换上下文时需要保存当  
前线程的执行现场，当再次执行时根据保存的执行现场信息恢复执行现场。
线程上下文切换的时机：
当前线程的cpu时间片使用完处于就绪状态时，当前线程被其他线程中断时