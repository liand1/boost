### CompletableFuture：组合式异步编程
本章内容
> + 创建异步计算，并获取计算结果  
> + 使用非阻塞操作提升吞吐量  
> + 设计和实现异步API  
> + 如何以异步的方式使用同步的API  
> + 如何对两个或多个异步操作进行流水线和合并操作  
> + 如何处理异步操作的完成状态  

case1: Future 接口和它的局限性  
case2：使用 CompletableFuture 构建异步应用   
case3：对 CompletableFuture 进行异常处理
case4: 使用工厂方法supplyAsync创建CompletableFuture,精简代码
case5: 使用并行流对请求进行并行操作 ( 仔细阅读, 并行优化)  
+ >调整线程池的大小
《Java并发编程实战》（http://mng.bz/979c）一书中，Brian Goetz和合著者们为线程池大小
的优化提供了不少中肯的建议。这非常重要，如果线程池中线程的数量过多，最终它们会竞争
稀缺的处理器和内存资源，浪费大量的时间在上下文切换上。反之，如果线程的数目过少，正
如你的应用所面临的情况，处理器的一些核可能就无法充分利用。Brian Goetz建议，线程池大
小与处理器的利用率之比可以使用下面的公式进行估算：
Nthreads = NCPU * UCPU * (1 + W/C)
其中：
❑NCPU是处理器的核的数目，可以通过Runtime.getRuntime().availableProcessors()得到
❑UCPU是期望的CPU利用率（该值应该介于0和1之间）
❑W/C是等待时间与计算时间的比率

+ > 并行——使用流还是CompletableFutures？
目前为止，你已经知道对集合进行并行计算有两种方式：要么将其转化为并行流，利用map
这样的操作开展工作，要么枚举出集合中的每一个元素，创建新的线程，在CompletableFuture内对其进行操作。后者提供了更多的灵活性，你可以调整线程池的大小，而这能帮助
你确保整体的计算不会因为线程都在等待I/O而发生阻塞。
我们对使用这些API的建议如下。
❑如果你进行的是计算密集型的操作，并且没有I/O，那么推荐使用Stream接口，因为实
现简单，同时效率也可能是最高的（如果所有的线程都是计算密集型的，那就没有必要
创建比处理器核数更多的线程）。
❑反之，如果你并行的工作单元还涉及等待I/O的操作（包括网络连接等待），那么使用
CompletableFuture灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者
W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的
流水线中如果发生I/O等待，流的延迟特性会让我们很难判断到底什么时候触发了等待。 
   

