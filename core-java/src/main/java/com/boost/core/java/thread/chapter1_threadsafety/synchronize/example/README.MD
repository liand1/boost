### synchronized
  >synchronized块是 Java 提供的一种原子性 内 置锁, Java 中的每个对象都可以把它当作
一个同步锁来使用 , 这些 Java 内置的使用者看不到的锁被称为内部锁 ,也 叫 作监 视器锁。
线程的执行代码在进入 synchronized 代码块前会自动获取内部锁,这时候其他线程访 问 该
同步代码块 时会被阻塞挂起 。拿 到内部锁的线程会在正常退出同步代码块或者抛出 异 常后
或者在同步块内调用了该内置锁资源 的 wait系列方法时释放该内置锁 。 内置锁是排 它锁 ,
也 就是当一个 线程获取这个锁后 , 其他线程必须等待该线程释放锁后才能获取该锁 。
	另外,由于 Java 中的线程是与操作系统的原生线程 一一 对应的,所以当阻塞 一个线
程时伞,需要从用户态切换到内核态执行阻塞 操作,这是很耗时的操作,而 synchronized 的
使用就会导致上下文切换。
---
### synchronized 的内存语义
   >前面介绍了共享变量 内存可见性问题主要是由于线程的工作内存导致的,下面我们 来
讲解 synchronized 的 一 个内存语义,这个内存语义就可以解决共享变量内存可见性问题 。
进入 synchronized 块的内存语义是把在 synchronized 块内使用到的变量从线程的工作内存
中清除,这样在 synchronized 块内使用到该变 量 时就不会从线程的工作内存中获取,而是
直接从主内存中获取 。 退出 synchronized 块的内存语义是把在 synchronized 块内对共享变
量 的 修改刷新到主内存 。
其实这也是加锁和释放锁的语义,==当获取锁后会清空锁块内本地内存中将会被用到的
共享变 量 ,在使用这些共 享变量 时从主 内 存进行加载,在释放锁时将本地内存中修改的共
享变量刷新到主内存 。==
除可以解决共享变 量 内存可见性问题外, synchronized 经常被用来实现原子性操作 。
另外请注意, synchronized关键字会引起线程上下文切换并带来线程调度开销 。
---  
+ case2:加锁和不加锁的方法一起执行  
+ case3:脏读  
+ case4:一个同步方法调用另外一个同步方法,可重入  
+ case5:继承中，子类调用父类的同步方法，也是可重入的  
+ case6:程序执行过程中，如果出现异常，默认情况锁会被释放  
+ case7:不要以字符串常量作为锁定对象  
+ case8:锁的信息是记录在堆内存中的，不是在栈中，所以我们可以知道锁的是对象  
+ case9:同步不具有继承性  
+ case10:synchronized声明在方法上的弊端  
+ case11-14:将任意对象作为监视器，同步和异步  
+ case15-17:死锁  