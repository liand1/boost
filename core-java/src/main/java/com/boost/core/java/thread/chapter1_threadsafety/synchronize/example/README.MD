case2:加锁和不加锁的方法一起执行  
case3:脏读  
case4:一个同步方法调用另外一个同步方法,可重入  
case5:继承中，子类调用父类的同步方法，也是可重入的  
case6:程序执行过程中，如果出现异常，默认情况锁会被释放  
case7:不要以字符串常量作为锁定对象  
case8:锁的信息是记录在堆内存中的，不是在栈中，所以我们可以知道锁的是对象  
case9:同步不具有继承性  
case10:synchronized声明在方法上的弊端  
case11-14:将任意对象作为监视器，同步和异步  
case15-17:死锁  