### synchronized
  >synchronized块是 Java 提供的一种原子性 内 置锁, Java 中的每个对象都可以把它当作
一个同步锁来使用 , 这些 Java 内置的使用者看不到的锁被称为内部锁 ,也 叫 作监 视器锁。
线程的执行代码在进入 synchronized 代码块前会自动获取内部锁,这时候其他线程访 问 该
同步代码块 时会被阻塞挂起 。拿 到内部锁的线程会在正常退出同步代码块或者抛出 异 常后
或者在同步块内调用了该内置锁资源 的 wait系列方法时释放该内置锁 。 内置锁是排 它锁 ,
也 就是当一个 线程获取这个锁后 , 其他线程必须等待该线程释放锁后才能获取该锁 。
	另外,由于 Java 中的线程是与操作系统的原生线程 一一 对应的,所以当阻塞 一个线
程时伞,需要从用户态切换到内核态执行阻塞 操作,这是很耗时的操作,而 synchronized 的
使用就会导致上下文切换。
---
### synchronized 的内存语义  
   >前面介绍了共享变量 内存可见性问题主要是由于线程的工作内存导致的,下面我们 来
讲解 synchronized 的 一 个内存语义,这个内存语义就可以解决共享变量内存可见性问题 。
进入 synchronized 块的内存语义是把在 synchronized 块内使用到的变量从线程的工作内存
中清除,这样在 synchronized 块内使用到该变 量 时就不会从线程的工作内存中获取,而是
直接从主内存中获取 。 退出 synchronized 块的内存语义是把在 synchronized 块内对共享变
量 的 修改刷新到主内存 。
其实这也是加锁和释放锁的语义,==当获取锁后会清空锁块内本地内存中将会被用到的
共享变 量 ,在使用这些共 享变量 时从主 内 存进行加载,在释放锁时将本地内存中修改的共
享变量刷新到主内存 。==
除可以解决共享变 量 内存可见性问题外, synchronized 经常被用来实现原子性操作 。
另外请注意, synchronized关键字会引起线程上下文切换并带来线程调度开销 。
---  
### 公平锁与非公平锁  
根据线程获取锁的抢占机制,锁可以分为公平锁和非公平锁：
+ >公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的,也就是最早请求锁的线程将最早获取到锁.而非公平锁则在运行
时闯入,也就是先来不一定先得.
### 独占锁与共享锁  
根据锁只能被单个线程持有还是能被多个线程共同持有,锁可以分为独占锁和共享锁.  
+ >独占锁保证任何时候都只有一个线程能得到锁,ReentrantLock就是以独占方式实现  
的.共享锁则可以同时由多个线程持有,例如ReadWriteLock读写锁,它允许一个资源可  
以被多线程同时进行读操作.  
独占锁是一种悲观锁,由于每次访问资源都先加上互斥锁,这限制了并发性,因为读  
操作并不会影响数据的一致性,而独占锁只允许在同一时间由一个线程读取数据,其他线  
程必须等待当前线程释放锁才能进行读取.  
共享锁则是一种乐观锁,它放宽了加锁的条件,允许多个线程同时进行读操作.    
### 可重入锁  
+ >当一个线程要获取一个被其他线程持有的独占锁时,该线程会被阻塞,那么当一个线
程再次获取它自己己经获取的锁时是否会被阻塞呢?如果不被阻塞,那么我们说该锁是可
重入的,也就是只要该线程获取了该锁,那么可以无限次数(**在高级篇中我们将知道,严格来说是有限次数**)地进入被该锁锁住的代码.  
 实际上,synchronized内部锁是可重入锁.可重入锁的原理是在锁内部维护一个线程标示,用来标示该锁目前被哪个线程占用,然后关联
 一个计数器.一开始计数器值为o,说明该锁没有被任何线程占用.当一个钱程获取了该锁时,计数器的值会变成1,这时其他线程再来获取
 该锁时会发现锁的所有者不是自己而被阻塞挂起.但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己,就会把计数器值加+1,当
 释放锁后计数器值-1.当计数器值为0时-,锁里面的线程标示被重置为null,这时候被阻塞的线程会被唤醒来竞争获取该锁.
### 自旋锁  
+ >由于Java中的线程是与操作系统中的线程一一对应的,所以当一个线程在获取锁(比  
如独占锁)失败后,会被切换到内核状态而被挂起.当该线程获取到锁时又需要将其切换  
到内核状态而唤醒该线程.而从用户状态切换到内核状态的开销是比较大的,在一定程度  
上会影响并发性能.自旋锁则是,当前线程在获取锁时,如果发现锁已经被其他线程占有,  
它不马上阻塞自己,在不放弃CPU使用权的情况下,多次尝试获取(默认次数是10,可  
以使用-XX:PreBlockSpinsh参数设置该值),很有可能在后面几次尝试中其他线程己经释  
放了锁.如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起.由此看来自  
旋锁是使用CPU时间换取线程阻塞与调度的开销,但是很有可能这些CPU时间白白浪费  
了.  
  


+ case2:加锁和不加锁的方法一起执行  
+ case3:脏读  
+ case4:一个同步方法调用另外一个同步方法,可重入  
+ case5:继承中，子类调用父类的同步方法，也是可重入的  
+ case6:程序执行过程中，如果出现异常，默认情况锁会被释放  
+ case7:不要以字符串常量作为锁定对象  
+ case8:锁的信息是记录在堆内存中的，不是在栈中，所以我们可以知道锁的是对象  
+ case9:同步不具有继承性  
+ case10:synchronized声明在方法上的弊端  
+ case11-14:将任意对象作为监视器，同步和异步  
+ case15-17:死锁  
+ case18:指令重排  